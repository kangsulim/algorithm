# 📊 구간 합(Prefix Sum)

## ✅ 구간 합(Prefix Sum)이란?

배열의 **특정 구간** $[i, j]$의 **합을 빠르게 구하기 위해 사용하는 알고리즘 기법**입니다.

* 일반적으로 구간합을 직접 구하면 시간복잡도는 O(n)
* \*\*구간합 배열(Prefix Sum 배열)\*\*을 미리 만들어두면, 특정 구간의 합을 \*\*O(1)\*\*에 구할 수 있습니다

---

## 🔍 사용 목적

* 시간 초과를 방지하고 빠른 결과를 얻기 위해
* 배열의 범위가 크거나, 구간합을 여러 번 구해야 할 때 유리
* 코딩테스트 필수 테크닉 (구간합, 누적합, 슬라이딩 윈도우 문제에서 자주 등장)

---

## 🧮 핵심 이론

### ✅ 원본 배열 `A` 예시

```text
A = {1, 2, 3, 4}
```

### ✅ 합 배열 `S` 만들기 (0-based index)

| i | A\[i] | S\[i] |
| - | ----- | ----- |
| 0 | 1     | 1     |
| 1 | 2     | 3     |
| 2 | 3     | 6     |
| 3 | 4     | 10    |

**계산 방법:**

```java
S[0] = A[0]
S[i] = S[i - 1] + A[i]
```

---

## ⚙️ 구간합 계산 공식

구간 `[i, j]`의 합을 구하려면?

```java
sum = S[j] - S[i - 1];
```

단, `i == 0`이면 `S[j]`가 구간합이 됩니다.

예시:

```text
A = {1, 2, 3, 4, 5}
S = {1, 3, 6, 10, 15}

A[1] ~ A[3] = 2 + 3 + 4 = 9
S[3] - S[0] = 10 - 1 = 9
```

---

## ⏱ 시간 복잡도 비교

| 방식     | 초기화 비용 | 쿼리당 시간 | 동작 |
| ------ | ------ | ------ |----|
| 직접 계산  | 없음     | O(n)   | 느림 |
| 구간합 배열 | O(n)   | O(1)   | 빠름 |

---

## 📌 실전 예제

배열 A에서 여러 구간의 합을 빠르게 구하는 프로그램

```java
int[] A = {1, 2, 3, 4, 5};
int[] S = new int[A.length];

S[0] = A[0];
for (int i = 1; i < A.length; i++) {
    S[i] = S[i - 1] + A[i];
}

// 구간 A[1] ~ A[3] 합 구하기
int i = 1;
int j = 3;

int result = S[j] - (i > 0 ? S[i - 1] : 0);
System.out.println(result); // 출력: 9
```

---

## 🧠 실전에서 언제 쓰나?

* 제한 시간이 빡빡한 문제에서 반복 구간합 쿼리를 처리할 때
* 누적 점수, 투표 수, 거래량 등 통계를 빠르게 계산할 때
* 슬라이딩 윈도우, 2차원 배열 누적합, 나머지 합(누적합 % M) 등의 확장 문제

---

## 📌 기억할 점

* 합 배열은 **처음에 한 번만 만들고**, 이후 연산은 매우 빠르게 처리 가능
* **구간합 공식은 S\[j] - S\[i-1]**
* **0번 인덱스 고려 주의!** (보통 `i == 0`일 때는 별도 처리, S[0] = A[0])

---

## 🧾 추가 개념: 1-based vs 0-based

* 문제에 따라 배열 인덱스가 1부터 시작할 수도 있음
* 이때는 `S[0] = 0`으로 두고 `S[i] = S[i - 1] + A[i]`로 처리하면 편함

예시:

```java
int[] A = new int[N + 1];
int[] S = new int[N + 1];

S[0] = 0;
for (int i = 1; i <= N; i++) {
    S[i] = S[i - 1] + A[i];
}

// 구간 A[i] ~ A[j]는 S[j] - S[i - 1]
```

---

## ✅ 결론

> \*\*구간합(Prefix Sum)\*\*은 시간복잡도를 줄이기 위한 알고리즘에서 매우 중요하며,
> 코딩테스트에서도 자주 등장하는 **필수 패턴**입니다.
> 반드시 숙지하고 실전 문제에 적용해보세요!

---

1-based와 0-based에 대한 추가적인 학습이 필요하다면 아래의 링크를 참고해주세요.