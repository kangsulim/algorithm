## 🧾 추가 개념: 1-based vs 0-based Index

### ✅ 먼저, 인덱스(Index)란?

* 배열 A의 각 원소에 접근할 때 사용하는 번호
* **0-based index**: Java, C, Python 등 대부분의 언어에서 기본
* **1-based index**: 일부 알고리즘 문제 또는 수학 공식에서 사용

---

## 📘 0-based Index (Java 기본 방식)

```java
int[] A = {1, 2, 3, 4, 5}; // A[0] ~ A[4]
```

### 합 배열 S 생성:

```java
S[0] = A[0];
for (int i = 1; i < A.length; i++) {
    S[i] = S[i - 1] + A[i];
}
```

### 구간 A\[i] \~ A\[j]의 합 구하기:

* 공식:
  **`S[j] - S[i - 1]`**
* 단, `i == 0`이면 `S[j]` 그대로 사용해야 함

---

## 📙 1-based Index (보통 알고리즘 문제에서 많이 사용됨)

문제에서 **1번째 원소부터 시작한다면**, 인덱스가 1부터 시작해야 헷갈리지 않음

```java
int[] A = new int[N + 1]; // A[1] ~ A[N]
int[] S = new int[N + 1];

S[0] = 0;
for (int i = 1; i <= N; i++) {
    S[i] = S[i - 1] + A[i];
}
```

### 구간 A\[i] \~ A\[j]의 합:

* 공식:
  **`S[j] - S[i - 1]`** (항상 안전하게 작동함!)

### 왜 좋을까?

* 항상 공식이 **같은 구조** (`S[j] - S[i-1]`)를 유지하므로 **i == 0 처리** 고민이 사라짐
* 반복문도 `1부터 N까지` 명확하게 반복 가능
* **코딩테스트에서 많이 씀**

---

## 💡 비교 요약

| 구분            | 0-based                     | 1-based                    |
| ------------- | --------------------------- | -------------------------- |
| 배열 시작 인덱스     | 0                           | 1                          |
| S\[0] 초기값     | A\[0]                       | 0 (`S[0] = 0`)             |
| 합 공식          | `S[j] - S[i-1]` (i>0)       | `S[j] - S[i-1]` (항상 사용 가능) |
| i=0 예외 처리 필요? | ✔️ 필요함 (`i==0`이면 그냥 `S[j]`) | ❌ 예외 처리 없음                 |

---

## ✅ 결론

> **1-based 방식**을 사용하면 구간합을 처리할 때 더 안정적이고 코드가 깔끔해지는 장점이 있습니다.
> 코딩테스트나 복잡한 범위 문제에서는 **1-based 방식 추천**!
