# 🕒 시간 복잡도(Time Complexity) 정리

## 📘 시간 복잡도란?

- **알고리즘이 문제를 해결하는 데 걸리는 시간을 입력 크기(N)에 대한 함수로 표현한 것**입니다.
- 실제 시간(초 단위)이 아닌, **연산 횟수의 증가 속도**를 중심으로 판단합니다.
- 시간 복잡도를 분석함으로써, **입력 크기가 커졌을 때 프로그램이 시간 내에 실행 가능한지 예측**할 수 있습니다.

---

## 📌 시간 복잡도의 표기법 종류

### 1. **빅 오메가 (Ω)**

- **Best Case (최선의 경우)**
- 알고리즘이 **가장 빠르게 동작할 때**의 수행 시간

### 2. **빅 세타 (Θ)**

- **Average Case (평균적인 경우)**
- 알고리즘이 **평균적으로 수행되는 시간**

### 3. **빅 오 (O)** ⭐

- **Worst Case (최악의 경우)**
- 알고리즘이 **가장 오래 걸리는 경우**를 기준
- **코딩 테스트에서는 주로 빅 오를 사용**

### 표로 정리

| 표기법            | 의미                              | 설명                                        |
| ----------------- | --------------------------------- | ------------------------------------------- |
| **O (빅 오)**     | **최악의 경우 시간 (Worst Case)** | 가장 오래 걸릴 때 시간 ⏱️ (코딩테스트 기준) |
| **Ω (빅 오메가)** | 최선의 경우 시간 (Best Case)      | 가장 빠르게 끝나는 경우                     |
| **Θ (빅 세타)**   | 평균적인 경우 시간 (Average Case) | 평균적으로 걸리는 시간                      |

> ✅ **코딩테스트에서는 `빅 O` 위주로 분석**
> → 문제에서 주어진 입력 범위와 시간 제한에 따라 적절한 알고리즘을 선택해야 함.

---

## 🧠 코딩 테스트에서의 시간 복잡도 기준

- **1초에 약 `10⁸` (1억)번의 연산이 가능하다고 가정**
- 입력 크기와 시간 복잡도에 따라 통과 가능 여부를 판단

| 시간 복잡도    | 입력 크기 제한 N의 최대값 | 예시 알고리즘            | 비고                      |
| -------------- | ------------------------- | ------------------------ | ------------------------- |
| **O(1)**       | 제한 없음                 | 해시 탐색, 조건문        | 연산 수 고정              |
| **O(log N)**   | ≤ 10⁸                     | 이진 탐색                | 로그 성장은 매우 느림     |
| **O(N)**       | ≤ 10⁷                     | 선형 탐색, 단일 루프     | 빠름                      |
| **O(N log N)** | ≤ 10⁶                     | 병합 정렬, 퀵 정렬       | 일반적인 정렬 알고리즘    |
| **O(N²)**      | ≤ 10³ \~ 2×10³            | 버블 정렬, 선택 정렬     | 이중 반복문이면 주의 필요 |
| **O(2ⁿ)**      | ≤ 20                      | 백트래킹, 재귀 완전 탐색 | 지수 성장 → 매우 느림     |
| **O(N!)**      | ≤ 10                      | 순열 생성, 여행자 문제   | 팩토리얼 성장은 매우 큼   |

---

## 🆚 버블 정렬 vs 병합 정렬

입력 크기: **0 \~ 100,000 (10⁵)**

| 정렬 알고리즘 | 시간 복잡도 (O) | 연산 횟수 예상                    | 적합성    |
| ------------- | --------------- | --------------------------------- | --------- |
| **버블 정렬** | O(N²)           | 100,000² = 10¹⁰ (시간 초과!)      | ❌ 부적합 |
| **병합 정렬** | O(N log N)      | 100,000 × log₂100,000 ≈ 1,700,000 | ✅ 적합   |

➡️ **대규모 입력일수록 O(N log N) 이상의 효율적인 정렬 알고리즘을 선택해야 함**

---

## ✅ 코딩테스트 팁

> ⛔ "알고리즘은 맞는 것 같은데 시간 초과가 난다?"
> → **내 코드가 진짜 효율적인지 점검!**

### 💬 확인 포인트

- **복잡도가 높은 알고리즘 사용은 아닌가?** → N² 이상은 위험!
- **중복 루프/불필요한 연산은 없는가?**
- **적절한 자료구조를 사용했는가?** → 배열 대신 해시, 우선순위 큐 등

### 💡 해결 방법

- 알고리즘 자체를 변경 (ex. 완전탐색 → 그리디, 정렬 등)
- 반복문 줄이기 / 조건문 최적화
- 자료구조 교체로 탐색 속도 향상

---

코딩테스트 대비를 위해 알고리즘 공부 및 코딩테스트 문제를 풀어보기로 결심했습니다.

당장에 자격증 준비와 국비 수업 진행(팀 프로젝트)으로 한 번에 많은 양을 다루지는 못 하지만,

인프런 무료 강의를 통해 하루에 한 강의라도 수강하는 것과 프로그래머스 문제 level 0부터 차근차근 도전해보려고 합니다.

두 곳 모두 깃허브 계정과도 연동 되니 편한 점이 많아요!

인프런 무료 강의
: https://www.inflearn.com/course/%EB%91%90%EC%9E%87-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9E%90%EB%B0%94

프로그래머스
: https://programmers.co.kr/
